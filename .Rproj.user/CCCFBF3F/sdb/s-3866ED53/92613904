{
    "collab_server" : "",
    "contents" : "# install and load the needed packages ------------------------------------\nused_packages <- c(\"lubridate\",   # date/time conversions\n                   \"caret\",       # cross-fold generation\n                   \"party\",       # decision tree classifier\n                   \"class\",       # kNN classifier\n                   \"e1071\",       # SVM classifier\n                   \"randomForest\", # random forest classifier\n                   \"forecast\"      # exponential smoothing\n)\nmissing_packages <- setdiff(used_packages, installed.packages())\nif(length(missing_packages)>0){install.packages(missing_packages)}\nlapply(used_packages, require, character.only = TRUE)\nrm(used_packages, missing_packages)\n\n# load the datasets ----\ntrades_ETHEUR <- read.csv(\"trades_ETHEUR.csv\", encoding = \"UTF-8\")\n#trades_XBTEUR <- read.csv(\"trades_XBTEUR.csv\", encoding = \"UTF-8\")\n\n# ETHEUR Trades: between 2015-08-07 11:09:50 and 2017-06-28 20:51:20 ----\ntrades_ETHEUR$Time_Format <- as_datetime(trades_ETHEUR$Time)\ntrades_ETHEUR$BS <- as.factor(trades_ETHEUR$BS)\ntrades_ETHEUR$ML <- as.factor(trades_ETHEUR$ML)\nsummary(trades_ETHEUR$Time_Format)\n\n\n\n#> calculate features per day ----\ntrades_ETHEUR$day <- date(trades_ETHEUR$Time_Format)\ndailystats_ETHEUR <- data.frame(\n  #avg_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, mean), #TODO: is that correct?\n  min_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, min), \n  max_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, max), \n  volume = tapply(trades_ETHEUR$Volume, trades_ETHEUR$day, sum)\n)\n\nopen_times = tapply(trades_ETHEUR$Time, trades_ETHEUR$day, min)\nclose_times = tapply(trades_ETHEUR$Time, trades_ETHEUR$day, max)\n\ndailystats_ETHEUR$open <- trades_ETHEUR$Price[match(open_times, trades_ETHEUR$Time)]\ndailystats_ETHEUR$close <- trades_ETHEUR$Price[match(close_times, trades_ETHEUR$Time)]\n\n\nprice_diff_1d <- 0\ndailystats_ETHEUR$price_rateOfChange_1d <- 0\ndailystats_ETHEUR$price_rsi <-0\ndailystats_ETHEUR$stochastic_oscilator <- 0\ndailystats_ETHEUR$williams <- 0\n\ndailystats_ETHEUR$obv <- 0\ndailystats_ETHEUR$price_var_10d <- 0\n\ndailystats_ETHEUR$price_rateOfChange_2d <- 0\ndailystats_ETHEUR$price_rateOfChange_3d <- 0\ndailystats_ETHEUR$price_rateOfChange_4d <- 0\ndailystats_ETHEUR$price_rateOfChange_5d <- 0\n\n\ngain_average <- 0\nloss_average <- 0\n\n\n\nfor(i in 15:(nrow(dailystats_ETHEUR))){\n  #Price Rate of Change\n  price_diff_1d[i] <- dailystats_ETHEUR$close[i] - dailystats_ETHEUR$close[i-1]\n  \n  dailystats_ETHEUR[i, c(\"price_rateOfChange_1d\", \"price_rateOfChange_2d\", \"price_rateOfChange_3d\", \"price_rateOfChange_4d\", \"price_rateOfChange_5d\")] <- \n    (dailystats_ETHEUR$close[i] - dailystats_ETHEUR$close[i-c(1:5)])#/dailystats_ETHEUR$close[i-c(1:5)]\n  \n  #Relative Strength Index\n  gain_average <- mean(price_diff_1d [i + 1 - which(price_diff_1d[i- c(1:14)] > 0)])\n  loss_average <- abs(mean(price_diff_1d [i + 1 - which(price_diff_1d[i- c(1:14)] < 0)]))\n  \n  dailystats_ETHEUR$price_rsi[i] <- (100 - 100/(1 + gain_average/loss_average))\n  \n  dailystats_ETHEUR$price_var_10d[i] <- var(dailystats_ETHEUR$close[i-c(0:9)])\n  \n  low14 <- min(dailystats_ETHEUR$min_price[i- c( 1 : 14)])\n  high14 <- max(dailystats_ETHEUR$max_price[i- c( 1 : 14)])\n  \n  #Stochastic oscilator\n  dailystats_ETHEUR$stochastic_oscilator[i] <- 100 * (dailystats_ETHEUR$close[i] - low14)/(high14 - low14)\n  \n  #Williams %R\n  dailystats_ETHEUR$williams[i] <- (high14 - dailystats_ETHEUR$close[i])/(high14 - low14) * (-100)\n  \n  #On Balance Volume\n  if(price_diff_1d[i] > 0 ) {\n\n    dailystats_ETHEUR$obv[i] <- dailystats_ETHEUR$obv[i-1] + dailystats_ETHEUR$volume[i]\n\n  }else if( price_diff_1d[i] < 0){\n\n    dailystats_ETHEUR$obv[i] <- dailystats_ETHEUR$obv[i-1] - dailystats_ETHEUR$volume[i]\n  }else {\n    dailystats_ETHEUR$obv[i] <- dailystats_ETHEUR$obv[i-1]\n  }\n}\n\n\n#> plot the price ranges per day ----\nplot(dailystats_ETHEUR$close, type=\"l\", ylim=c(0,400), main=\"Price per day ETHEUR\",\n     ylab=\"ETHEUR\", xlab=\"Day since 2015-08-07\")\n# lines(dailystats_ETHEUR$max_price, col=2)\n# lines(dailystats_ETHEUR$min_price, col=2)\npolygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),\n        y=c(dailystats_ETHEUR$max_price, \n            dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]), \n        col = \"lightblue\", border = \"lightblue\")\nlines(dailystats_ETHEUR$close)\n\n#> prepare classification ----\n\nthreshold <- 0.125 * sd(diff(dailystats_ETHEUR$close))\n\ndailystats_ETHEUR$nextdayprice <- \"\"\nfor(i in 1:(nrow(dailystats_ETHEUR)-1)){\n  diff_nextday <- dailystats_ETHEUR$close[i+1] - dailystats_ETHEUR$close[i]\n  if(diff_nextday > threshold){\n    dailystats_ETHEUR$nextdayprice[i] <- \"higher\"\n  } else if(diff_nextday < -threshold){\n    dailystats_ETHEUR$nextdayprice[i] <- \"lower\"\n  } else {\n    dailystats_ETHEUR$nextdayprice[i] <- \"equal\"\n  }\n}\ndailystats_ETHEUR$nextdayprice[dailystats_ETHEUR$nextdayprice==\"\"] <- NA\ndailystats_ETHEUR$nextdayprice <- ordered(dailystats_ETHEUR$nextdayprice, \n                                          levels=c(\"lower\",\"equal\" ,\"higher\"))\n\nsummary(dailystats_ETHEUR$nextdayprice)\n\n#> prepare data for classification ----\n\n#remove NA rows\ndailystats_ETHEUR <- dailystats_ETHEUR[!apply(dailystats_ETHEUR, 1, anyNA), ]\n\n# divide data in cross-folds\nset.seed(1000)\nxfolds <- createFolds(dailystats_ETHEUR$nextdayprice, k=10)\n\n#> classification algorithms ----§§§\n\n#the IDs for training and validation\ntest_cases     <- 1:nrow(dailystats_ETHEUR) %in% xfolds$Fold01\ntraining_cases <- !test_cases\n\n#>> decisoon tree ----\n\n#train the model\nmodel_DT <- ctree(nextdayprice ~ . , \n                  data=dailystats_ETHEUR[training_cases, ])\n\n#predict test cases\nclres_DT <- predict(model_DT, newdata=dailystats_ETHEUR[test_cases,])\n\n#inspect the model - here the decision tree with decision borders and the distributions of the classes\nplot(model_DT)\n\n#>> random forest ----\n\n#train the model\nmodel_RF <- randomForest(nextdayprice ~ . , \n                         data=dailystats_ETHEUR[training_cases, ],\n                         importance=T)\n\n#predict test cases\nclres_RF <- predict(model_RF, newdata=dailystats_ETHEUR[test_cases,])\n\n#inspect the model - here variable importances, see ?importance for the definition of measures\nimportance(model_RF)\n\n#>> kNN ----\nfeatures <- setdiff(colnames(dailystats_ETHEUR), \"nextdayprice\")\n\ntestdata  <- dailystats_ETHEUR[test_cases, ]\ntraindata <- dailystats_ETHEUR[training_cases, ]\n\n# predict test cases from training data (lazy learning algoritm has no explicit training step!)\nclres_KNN <- knn(train = traindata[, features], test = testdata[, features], \n                 cl = traindata$nextdayprice, k = 5)\n\n\n#>> kNN with probabilities ----\ntestdata  <- dailystats_ETHEUR[test_cases, ]\ntraindata <- dailystats_ETHEUR[training_cases, ]\n\nclres_KNN <- knn(train = traindata[, features], test = testdata[, features], \n                 cl = traindata$nextdayprice, k = 5, prob = T)\n\nprob <- attr(clres_KNN, \"prob\")\n\n\n#>> SVM ----\n\n#train the model\nmodel_SVM <- svm(nextdayprice ~ . , data=traindata)\n\n#predict the test cases\nclres_SVM <- predict(model_SVM, newdata=testdata)\n\n#>> SVM with probabilities ----\nmodel_SVM <- svm(nextdayprice ~ . , data=traindata, probability = T)\nclres_SVM <- predict(model_SVM, newdata=testdata, probability = T)\n\nhigh_buying_props <- order(attributes(clres_SVM)$probabilities[,\"higher\"], decreasing = T)\nattributes(clres_SVM)$probabilities[high_buying_props, ]\n\n\n#> Simple model evaluation ---------------------------------------------\n\ncm <- table(clres_RF, dailystats_ETHEUR[test_cases,\"nextdayprice\"])\n(accuracy_RF <- (sum(diag(cm))/sum(as.vector(cm))))\n\ncm <- table(clres_DT, dailystats_ETHEUR[test_cases,\"nextdayprice\"])\n(accuracy_DT <- (sum(diag(cm))/sum(as.vector(cm))))\n\ncm <- table(clres_SVM, dailystats_ETHEUR[test_cases,\"nextdayprice\"])\n(accuracy_SVM <- (sum(diag(cm))/sum(as.vector(cm))))\n\n\ncm <- table(clres_KNN, dailystats_ETHEUR[test_cases,\"nextdayprice\"])\n(accuracy_KNN <- (sum(diag(cm))/sum(as.vector(cm))))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# XBTEUR Trades: between 2013-09-10 23:47:11 and 2017-06-28 20:49:23 ----\n# trades_XBTEUR$Time_Format <- as_datetime(trades_XBTEUR$Time)\n# trades_XBTEUR$BS <- as.factor(trades_XBTEUR$BS)\n# trades_XBTEUR$ML <- as.factor(trades_XBTEUR$ML)\n# summary(trades_XBTEUR$Time_Format)\n\n",
    "created" : 1505223084747.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "526638253",
    "id" : "92613904",
    "lastKnownWriteTime" : 1505251412,
    "last_content_update" : 1505251412,
    "path" : "C:/workshop-bamberg/Kraken-Case/kraken/02_TradeClassification.R",
    "project_path" : "02_TradeClassification.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}