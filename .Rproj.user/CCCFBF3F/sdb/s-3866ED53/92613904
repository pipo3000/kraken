{
    "collab_server" : "",
    "contents" : "# install and load the needed packages ------------------------------------\nused_packages <- c(\"lubridate\",   # date/time conversions\n                   \"caret\",       # cross-fold generation\n                   \"party\",       # decision tree classifier\n                   \"class\",       # kNN classifier\n                   \"e1071\",       # SVM classifier\n                   \"randomForest\" # random forest classifier\n)\nmissing_packages <- setdiff(used_packages, installed.packages())\nif(length(missing_packages)>0){install.packages(missing_packages)}\nlapply(used_packages, require, character.only = TRUE)\nrm(used_packages, missing_packages)\n\n# load the datasets ----\ntrades_ETHEUR <- read.csv(\"trades_ETHEUR.csv\", encoding = \"UTF-8\")\n#trades_XBTEUR <- read.csv(\"trades_XBTEUR.csv\", encoding = \"UTF-8\")\n\n# ETHEUR Trades: between 2015-08-07 11:09:50 and 2017-06-28 20:51:20 ----\ntrades_ETHEUR$Time_Format <- as_datetime(trades_ETHEUR$Time)\ntrades_ETHEUR$BS <- as.factor(trades_ETHEUR$BS)\ntrades_ETHEUR$ML <- as.factor(trades_ETHEUR$ML)\nsummary(trades_ETHEUR$Time_Format)\n\n#> calculate features per day ----\ntrades_ETHEUR$day <- date(trades_ETHEUR$Time_Format)\ndailystats_ETHEUR <- data.frame(\n  avg_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, mean), #TODO: is that correct?\n  min_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, min), \n  max_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, max), \n  volume = tapply(trades_ETHEUR$Volume, trades_ETHEUR$day, sum)\n)\n\ndailystats_ETHEUR$price_diff_1d <- 0\ndailystats_ETHEUR$price_diff_2d <- 0\ndailystats_ETHEUR$price_diff_3d <- 0\ndailystats_ETHEUR$price_diff_4d <- 0\ndailystats_ETHEUR$price_diff_5d <- 0\ndailystats_ETHEUR$price_var_10d <- 0\n\nfor(i in 10:(nrow(dailystats_ETHEUR))){\n  dailystats_ETHEUR[i, c(\"price_diff_1d\", \"price_diff_2d\", \"price_diff_3d\",\n                         \"price_diff_4d\", \"price_diff_5d\")] <- \n    dailystats_ETHEUR$avg_price[i] - dailystats_ETHEUR$avg_price[i-c(1:5)]\n  dailystats_ETHEUR$price_var_10d[i] <- var(dailystats_ETHEUR$avg_price[i-c(0:9)])\n}\n\n#> plot the price ranges per day ----\nplot(dailystats_ETHEUR$avg_price, type=\"l\", ylim=c(0,400), main=\"Price per day ETHEUR\",\n     ylab=\"ETHEUR\", xlab=\"Day since 2015-08-07\")\n# lines(dailystats_ETHEUR$max_price, col=2)\n# lines(dailystats_ETHEUR$min_price, col=2)\npolygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),\n        y=c(dailystats_ETHEUR$max_price, \n            dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]), \n        col = \"lightblue\", border = \"lightblue\")\nlines(dailystats_ETHEUR$avg_price)\n\n#> prepare classification ----\n\nthreshold <- 0.125 * sd(diff(dailystats_ETHEUR$avg_price))\n\ndailystats_ETHEUR$nextdayprice <- \"\"\nfor(i in 1:(nrow(dailystats_ETHEUR)-1)){\n  diff_nextday <- dailystats_ETHEUR$avg_price[i+1] - dailystats_ETHEUR$avg_price[i]\n  if(diff_nextday > threshold){\n    dailystats_ETHEUR$nextdayprice[i] <- \"higher\"\n  } else if(diff_nextday < -threshold){\n    dailystats_ETHEUR$nextdayprice[i] <- \"lower\"\n  } else {\n    dailystats_ETHEUR$nextdayprice[i] <- \"equal\"\n  }\n}\ndailystats_ETHEUR$nextdayprice[dailystats_ETHEUR$nextdayprice==\"\"] <- NA\ndailystats_ETHEUR$nextdayprice <- ordered(dailystats_ETHEUR$nextdayprice, \n                                          levels=c(\"lower\", \"equal\", \"higher\"))\nsummary(dailystats_ETHEUR$nextdayprice)\n\n#> prepare data for classification ----\n\n#remove NA rows\ndailystats_ETHEUR <- dailystats_ETHEUR[!apply(dailystats_ETHEUR, 1, anyNA), ]\n\n# divide data in cross-folds\nset.seed(1000)\nxfolds <- createFolds(dailystats_ETHEUR$nextdayprice, k=10)\n\n#> classification algorithms ----\n\nfor(i in 1:10){\n\n  #the IDs for training and validation\n  test_cases     <- 1:nrow(dailystats_ETHEUR) %in% xfolds[[i]]\n  training_cases <- !test_cases\n  \n  #>> decisoon tree ----\n  \n  #train the model\n  model_DT <- ctree(nextdayprice ~ . , \n                    data=dailystats_ETHEUR[training_cases, ])\n  \n  #predict test cases\n  clres_DT <- predict(model_DT, newdata=dailystats_ETHEUR[test_cases,])\n  \n  #inspect the model - here the decision tree with decision borders and the distributions of the classes\n  plot(model_DT)\n  \n  #>> random forest ----\n  \n  #train the model\n  model_RF <- randomForest(nextdayprice ~ . , \n                           data=dailystats_ETHEUR[training_cases, ],\n                           importance=T)\n  \n  #predict test cases\n  clres_RF <- predict(model_RF, newdata=dailystats_ETHEUR[test_cases,])\n  \n  #inspect the model - here variable importances, see ?importance for the definition of measures\n  importance(model_RF)\n  \n  #>> kNN ----\n  features <- setdiff(colnames(dailystats_ETHEUR), \"nextdayprice\")\n  \n  testdata  <- dailystats_ETHEUR[test_cases, ]\n  traindata <- dailystats_ETHEUR[training_cases, ]\n  \n  # predict test cases from training data (lazy learning algoritm has no explicit training step!)\n  clres_KNN <- knn(train = traindata[, features], test = testdata[, features], \n                   cl = traindata$nextdayprice, k = 5)\n  \n  \n  #>> kNN with probabilities ----\n  testdata  <- dailystats_ETHEUR[test_cases, ]\n  traindata <- dailystats_ETHEUR[training_cases, ]\n  \n  clres_KNN <- knn(train = traindata[, features], test = testdata[, features], \n                   cl = traindata$nextdayprice, k = 5, prob = T)\n  \n  prob <- attr(clres_KNN, \"prob\")\n  \n  \n  #>> SVM ----\n  \n  #train the model\n  model_SVM <- svm(nextdayprice ~ . , data=traindata)\n  \n  #predict the test cases\n  clres_SVM <- predict(model_SVM, newdata=testdata)\n  \n  #>> SVM with probabilities ----\n  model_SVM <- svm(nextdayprice ~ . , data=traindata, probability = T)\n  clres_SVM <- predict(model_SVM, newdata=testdata, probability = T)\n  \n  high_buying_props <- order(attributes(clres_SVM)$probabilities[,\"higher\"], decreasing = T)\n  attributes(clres_SVM)$probabilities[high_buying_props, ]\n  \n  \n  #> Simple model evaluation ---------------------------------------------\n  \n  cm <- table(clres_RF, dailystats_ETHEUR[test_cases,\"nextdayprice\"])\n  (accuracy_RF <- (sum(diag(cm))/sum(as.vector(cm))))\n  \n  cm <- table(clres_DT, dailystats_ETHEUR[test_cases,\"nextdayprice\"])\n  (accuracy_DT <- (sum(diag(cm))/sum(as.vector(cm))))\n  \n  cm <- table(clres_SVM, dailystats_ETHEUR[test_cases,\"nextdayprice\"])\n  (accuracy_SVM <- (sum(diag(cm))/sum(as.vector(cm))))\n  \n  cm <- table(clres_KNN, dailystats_ETHEUR[test_cases,\"nextdayprice\"])\n  (accuracy_KNN <- (sum(diag(cm))/sum(as.vector(cm))))\n\n\n}\n\n\n\n# XBTEUR Trades: between 2013-09-10 23:47:11 and 2017-06-28 20:49:23 ----\n# trades_XBTEUR$Time_Format <- as_datetime(trades_XBTEUR$Time)\n# trades_XBTEUR$BS <- as.factor(trades_XBTEUR$BS)\n# trades_XBTEUR$ML <- as.factor(trades_XBTEUR$ML)\n# summary(trades_XBTEUR$Time_Format)\n\n",
    "created" : 1505223084747.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3072122008",
    "id" : "92613904",
    "lastKnownWriteTime" : 1505225169,
    "last_content_update" : 1505225169,
    "path" : "C:/Users/dfilipe/Dropbox/UniBA_MachineLearningWorkshop_DokSem2017/Kraken-Case/02_TradeClassification.R",
    "project_path" : "02_TradeClassification.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}