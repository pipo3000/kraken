install.packages("RSQLite")
library("RSQLite")
con <- dbConnect(drv=RSQLite::SQLite(), dbname="kraken.sqlite")
tables <- dbListTables(con)
tables <- tables[tables != "sqlite_sequence"]
lDataFrames <- vector("list", length=length(tables))
for (i in seq(along=tables)) {
lDataFrames[[i]] <- dbGetQuery(conn=con, statement=paste("SELECT * FROM '", tables[[i]], "'", sep=""))
}
lDataFrames
names(lDataFrames)
tables
trades_ETHEUR <- lDataFrames[[3]]
which(tables=="XBTEUR_Trades")
trades_ETHEUR <- lDataFrames[[which(tables=="ETHEUR_Trades")]]
trades_XBTEUR <- lDataFrames[[which(tables=="XBTEUR_Trades")]]
write.csv(trades_ETHEUR, "trades_ETHEUR.csv", fileEncoding = "UTF-8")
write.csv(trades_XBTEUR, "trades_XBTEUR.csv", fileEncoding = "UTF-8")
library(lubridate)
as_datetime(trades_ETHEUR[1:100])
as_datetime(trades_ETHEUR[1:100, "Time"])
trades_ETHEUR$Time_Format <- as_datetime(trades_ETHEUR$Time)
trades_ETHEUR$BS <- as.factor(trades_ETHEUR$BS)
trades_ETHEUR$ML <- as.factor(trades_ETHEUR$ML)
summary(as.factor(trades_ETHEUR$Misc))
summary(trades_ETHEUR$Time_Format)
trades_XBTEUR$Time_Format <- as_datetime(trades_XBTEUR$Time)
trades_XBTEUR$BS <- as.factor(trades_XBTEUR$BS)
trades_XBTEUR$ML <- as.factor(trades_XBTEUR$ML)
summary(trades_XBTEUR$Time_Format)
day(trades_ETHEUR$Time_Format[1])
date(trades_ETHEUR$Time_Format[1])
trades_ETHEUR$day <- date(trades_ETHEUR$Time_Format[1])
price_per_day <- tapply(trades_ETHEUR$Price, trades_ETHEUR$day, mean)
plot(price_per_day)
price_per_day
trades_ETHEUR$day <- date(trades_ETHEUR$Time_Format)
price_per_day <- tapply(trades_ETHEUR$Price, trades_ETHEUR$day, mean) #TODO: is that correct?
plot(price_per_day)
rm(price_per_day)
dailystats_ETHEUR <- data.frame(
avg_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, mean), #TODO: is that correct?
min_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, min),
max_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, min),
volume = tapply(trades_ETHEUR$Volume, trades_ETHEUR$day, sum)
)
plot(dailystats_ETHEUR$avg_price)
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price, dailystats_ETHEUR$min_price), col = "lightblue")
plot(dailystats_ETHEUR$avg_price)
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price)[nrow(dailystats_ETHEUR):1)], col = "lightblue")
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price)[nrow(dailystats_ETHEUR):1], col = "lightblue")
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]), col = "lightblue")
plot(dailystats_ETHEUR$avg_price, type="l")
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]), col = "lightblue")
lines(dailystats_ETHEUR$max_price, col=2)
lines(dailystats_ETHEUR$min_price, col=2)
plot(dailystats_ETHEUR$avg_price, type="l")
lines(dailystats_ETHEUR$max_price, col=2)
lines(dailystats_ETHEUR$min_price, col=2)
dailystats_ETHEUR <- data.frame(
avg_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, mean), #TODO: is that correct?
min_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, min),
max_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, max),
volume = tapply(trades_ETHEUR$Volume, trades_ETHEUR$day, sum)
)
plot(dailystats_ETHEUR$avg_price, type="l")
lines(dailystats_ETHEUR$max_price, col=2)
lines(dailystats_ETHEUR$min_price, col=2)
plot(dailystats_ETHEUR$avg_price, type="l", ylim=c(0,400))
lines(dailystats_ETHEUR$max_price, col=2)
lines(dailystats_ETHEUR$min_price, col=2)
plot(dailystats_ETHEUR$avg_price, type="l", ylim=c(0,400))
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]), col = "lightblue")
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]), col = "lightblue", border = 0)
plot(dailystats_ETHEUR$avg_price, type="l", ylim=c(0,400))
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]),
col = "lightblue", border = "lightblue")
lines(dailystats_ETHEUR$avg_price)
plot(dailystats_ETHEUR$avg_price, type="l", ylim=c(0,400), main="Price per day ETHEUR",
ylab="ETHEUR", xlab="Day since 2015-08-07")
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]),
col = "lightblue", border = "lightblue")
lines(dailystats_ETHEUR$avg_price)
?ifelse
dailystats_ETHEUR$nextdayprice <- character()
dailystats_ETHEUR$nextdayprice <- ""
diff(dailystats_ETHEUR$avg_price)
summary(diff(dailystats_ETHEUR$avg_price))
sd(diff(dailystats_ETHEUR$avg_price))
threshold <- 0.25 * sd(diff(dailystats_ETHEUR$avg_price))
threshold
threshold <- 0.5 * sd(diff(dailystats_ETHEUR$avg_price))
threshold
dailystats_ETHEUR$nextdayprice <- ""
for(i in 1:(nrow(dailystats_ETHEUR)-1)){
diff_nextday <- dailystats_ETHEUR$avg_price[i+1] - dailystats_ETHEUR$avg_price[i]
if(diff_nextday > threshold){
dailystats_ETHEUR$nextdayprice[i] <- "higher"
} else if(diff_nextday < -threshold){
dailystats_ETHEUR$nextdayprice[i] <- "lower"
} else {
dailystats_ETHEUR$nextdayprice[i] <- "equal"
}
}
dailystats_ETHEUR$nextdayprice[dailystats_ETHEUR$nextdayprice==""]
dailystats_ETHEUR$nextdayprice[dailystats_ETHEUR$nextdayprice==""] <- NA
dailystats_ETHEUR$nextdayprice <- ordered(dailystats_ETHEUR$nextdayprice,
levels=c("lower", "equal", "higher"))
summary(dailystats_ETHEUR$nextdayprice)
threshold <- 0.25 * sd(diff(dailystats_ETHEUR$avg_price))
dailystats_ETHEUR$nextdayprice <- ""
for(i in 1:(nrow(dailystats_ETHEUR)-1)){
diff_nextday <- dailystats_ETHEUR$avg_price[i+1] - dailystats_ETHEUR$avg_price[i]
if(diff_nextday > threshold){
dailystats_ETHEUR$nextdayprice[i] <- "higher"
} else if(diff_nextday < -threshold){
dailystats_ETHEUR$nextdayprice[i] <- "lower"
} else {
dailystats_ETHEUR$nextdayprice[i] <- "equal"
}
}
dailystats_ETHEUR$nextdayprice[dailystats_ETHEUR$nextdayprice==""] <- NA
dailystats_ETHEUR$nextdayprice <- ordered(dailystats_ETHEUR$nextdayprice,
levels=c("lower", "equal", "higher"))
summary(dailystats_ETHEUR$nextdayprice)
threshold <- 0.125 * sd(diff(dailystats_ETHEUR$avg_price))
dailystats_ETHEUR$nextdayprice <- ""
for(i in 1:(nrow(dailystats_ETHEUR)-1)){
diff_nextday <- dailystats_ETHEUR$avg_price[i+1] - dailystats_ETHEUR$avg_price[i]
if(diff_nextday > threshold){
dailystats_ETHEUR$nextdayprice[i] <- "higher"
} else if(diff_nextday < -threshold){
dailystats_ETHEUR$nextdayprice[i] <- "lower"
} else {
dailystats_ETHEUR$nextdayprice[i] <- "equal"
}
}
dailystats_ETHEUR$nextdayprice[dailystats_ETHEUR$nextdayprice==""] <- NA
dailystats_ETHEUR$nextdayprice <- ordered(dailystats_ETHEUR$nextdayprice,
levels=c("lower", "equal", "higher"))
summary(dailystats_ETHEUR$nextdayprice)
dailystats_ETHEUR$price_diff_1d <- 0
dailystats_ETHEUR$price_diff_2d <- 0
dailystats_ETHEUR$price_diff_3d <- 0
dailystats_ETHEUR$price_diff_4d <- 0
dailystats_ETHEUR$price_diff_5d <- 0
dailystats_ETHEUR$price_var_10d <- 0
dailystats_ETHEUR$avg_price[i-c(1:5)]
dailystats_ETHEUR$avg_price[i] - dailystats_ETHEUR$avg_price[i-c(1:5)]
dailystats_ETHEUR[i, c("price_diff_1d", "price_diff_2d", "price_diff_3d",
"price_diff_4d", "price_diff_5d")] <- dailystats_ETHEUR$avg_price[i] - dailystats_ETHEUR$avg_price[i-c(1:5)]
dailystats_ETHEUR$price_var_10d <- var(dailystats_ETHEUR$avg_price[i-c(0:9)])
for(i in 1:(nrow(dailystats_ETHEUR)-1)){
dailystats_ETHEUR[i, c("price_diff_1d", "price_diff_2d", "price_diff_3d",
"price_diff_4d", "price_diff_5d")] <-
dailystats_ETHEUR$avg_price[i] - dailystats_ETHEUR$avg_price[i-c(1:5)]
dailystats_ETHEUR$price_var_10d <- var(dailystats_ETHEUR$avg_price[i-c(0:9)])
}
for(i in 10:(nrow(dailystats_ETHEUR)-1)){
dailystats_ETHEUR[i, c("price_diff_1d", "price_diff_2d", "price_diff_3d",
"price_diff_4d", "price_diff_5d")] <-
dailystats_ETHEUR$avg_price[i] - dailystats_ETHEUR$avg_price[i-c(1:5)]
dailystats_ETHEUR$price_var_10d <- var(dailystats_ETHEUR$avg_price[i-c(0:9)])
}
for(i in 10:(nrow(dailystats_ETHEUR))){
dailystats_ETHEUR[i, c("price_diff_1d", "price_diff_2d", "price_diff_3d",
"price_diff_4d", "price_diff_5d")] <-
dailystats_ETHEUR$avg_price[i] - dailystats_ETHEUR$avg_price[i-c(1:5)]
dailystats_ETHEUR$price_var_10d <- var(dailystats_ETHEUR$avg_price[i-c(0:9)])
}
View(dailystats_ETHEUR)
i-c(0:9)
for(i in 10:(nrow(dailystats_ETHEUR))){
dailystats_ETHEUR[i, c("price_diff_1d", "price_diff_2d", "price_diff_3d",
"price_diff_4d", "price_diff_5d")] <-
dailystats_ETHEUR$avg_price[i] - dailystats_ETHEUR$avg_price[i-c(1:5)]
dailystats_ETHEUR$price_var_10d[i] <- var(dailystats_ETHEUR$avg_price[i-c(0:9)])
}
View(dailystats_ETHEUR)
runif(min=0, max=10)
runif(n=nrow(dailystats_ETHEUR), min=0, max=10)
round(runif(n=nrow(dailystats_ETHEUR), min=0, max=10))
ceil(runif(n=nrow(dailystats_ETHEUR), min=0, max=10))
ceiling(runif(n=nrow(dailystats_ETHEUR), min=0, max=10))
table(ceiling(runif(n=nrow(dailystats_ETHEUR), min=0, max=10)))
prop.table(table(ceiling(runif(n=nrow(dailystats_ETHEUR), min=0, max=10))))
library(caret)
createFolds(dailystats_ETHEUR$nextdayprice, k=10)
set.seed(1000)
xfolds <- createFolds(dailystats_ETHEUR$nextdayprice, k=10)
xfolds
set.seed(1000)
xfolds <- createFolds(dailystats_ETHEUR$nextdayprice, k=10)
xfolds
apply(dailystats_ETHEUR, 1, anyNA)
dailystats_ETHEUR <- dailystats_ETHEUR[!apply(dailystats_ETHEUR, 1, anyNA), ]
set.seed(1000)
xfolds <- createFolds(dailystats_ETHEUR$nextdayprice, k=10)
xfolds
model_DT <- ctree(nextdayprice ~ . ,
data=dailystats_ETHEUR)
used_packages <- c("lubridate",   # date/time conversions
"caret",       # cross-fold generation
"party",       # decision tree classifier
"class",       # kNN classifier
"e1071",       # SVM classifier
"randomForest" # random forest classifier
)
missing_packages <- setdiff(used_packages, installed.packages())
if(length(missing_packages)>0){install.packages(missing_packages)}
lapply(used_packages, require, character.only = TRUE)
rm(used_packages, missing_packages)
model_DT <- ctree(nextdayprice ~ . ,
data=dailystats_ETHEUR[-xfolds$Fold01])
test_cases     <- 1:nrow(dailystats_ETHEUR) %in% xfolds$Fold01
training_cases <- !test_cases
model_DT <- ctree(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ])
clres_DT <- predict(model_DT, newdata=dailystats_ETHEUR[test_cases,])
plot(model_DT)
model_RF <- randomForest(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ],
importance=T)
model_DT <- ctree(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ])
clres_DT <- predict(model_DT, newdata=dailystats_ETHEUR[test_cases,])
plot(model_DT)
model_RF <- randomForest(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ],
importance=T)
clres_RF <- predict(model_RF, newdata=alldata[test_cases,c("pNumResidents", features_selected)])
importance(model_RF)
used_packages <- c("lubridate",   # date/time conversions
"caret",       # cross-fold generation
"party",       # decision tree classifier
"class",       # kNN classifier
"e1071",       # SVM classifier
"randomForest" # random forest classifier
)
missing_packages <- setdiff(used_packages, installed.packages())
if(length(missing_packages)>0){install.packages(missing_packages)}
lapply(used_packages, require, character.only = TRUE)
rm(used_packages, missing_packages)
model_RF <- randomForest(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ],
importance=T)
clres_RF <- predict(model_RF, newdata=alldata[test_cases,c("pNumResidents", features_selected)])
importance(model_RF)
testdata <- na.omit(alldata[test_cases, c("pNumResidents", features_selected)])
traindata <- na.omit(alldata[-test_cases, c("pNumResidents", features_selected)])
testdata  <- dailystats_ETHEUR[test_cases, ])
testdata  <- dailystats_ETHEUR[test_cases, ]
traindata <- dailystats_ETHEUR[training_cases, ]
clres_KNN <- knn(train = traindata[,-1], test = testdata[,-1],
cl = traindata$nextdayprice, k = 5)
clres_KNN <- knn(train = traindata[,-1], test = testdata[,-1],
traindata$pNumResidents, k = 5, prob = T)
clres_KNN <- knn(train = traindata[,-1], test = testdata[,-1],
cl = traindata$nextdayprice, k = 5, prob = T)
prob <- attr(clres_KNN, "prob")
features <- setdiff(colnames(dailystats_ETHEUR), "nextdayprice")
features
clres_KNN <- knn(train = traindata[, features], test = testdata[, features],
cl = traindata$nextdayprice, k = 5)
testdata  <- dailystats_ETHEUR[test_cases, ]
traindata <- dailystats_ETHEUR[training_cases, ]
clres_KNN <- knn(train = traindata[, features], test = testdata[, features],
cl = traindata$nextdayprice, k = 5, prob = T)
prob <- attr(clres_KNN, "prob")
model_SVM <- svm(nextdayprice ~ . , data=traindata)
clres_SVM <- predict(model_SVM, newdata=testdata)
model_SVM <- svm(nextdayprice ~ . , data=traindata, probability = T)
clres_SVM <- predict(model_SVM, newdata=testdata, probability = T)
clres_SVM)$probabilities
attributes(clres_SVM)$probabilities
buys <- order(attributes(clres_SVM)$probabilities[,"higher"], decreasing = T)
buys
rm(buys)
high_buying_props <- order(attributes(clres_SVM)$probabilities[,"higher"], decreasing = T)
attributes(clres_SVM)$probabilities[high_buying_props, ]
cm <- table(clres_RF, alldata[test_cases,"nextdayprice"])
(accuracy_RF <- (sum(diag(cm))/sum(as.vector(cm))))
cm <- table(clres_DT, alldata[test_cases,"nextdayprice"])
(accuracy_DT <- (sum(diag(cm))/sum(as.vector(cm))))
cm <- table(clres_SVM, alldata[test_cases,"nextdayprice"])
(accuracy_SVM <- (sum(diag(cm))/sum(as.vector(cm))))
cm <- table(clres_KNN, alldata[test_cases,"nextdayprice"])
(accuracy_KNN <- (sum(diag(cm))/sum(as.vector(cm))))
clres_RF
model_DT <- ctree(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ])
clres_DT <- predict(model_DT, newdata=dailystats_ETHEUR[test_cases,])
plot(model_DT)
model_RF <- randomForest(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ],
importance=T)
clres_RF <- predict(model_RF, newdata=alldata[test_cases,c("pNumResidents", features_selected)])
importance(model_RF)
features <- setdiff(colnames(dailystats_ETHEUR), "nextdayprice")
testdata  <- dailystats_ETHEUR[test_cases, ]
traindata <- dailystats_ETHEUR[training_cases, ]
clres_KNN <- knn(train = traindata[, features], test = testdata[, features],
cl = traindata$nextdayprice, k = 5)
testdata  <- dailystats_ETHEUR[test_cases, ]
traindata <- dailystats_ETHEUR[training_cases, ]
clres_KNN <- knn(train = traindata[, features], test = testdata[, features],
cl = traindata$nextdayprice, k = 5, prob = T)
prob <- attr(clres_KNN, "prob")
model_SVM <- svm(nextdayprice ~ . , data=traindata)
clres_SVM <- predict(model_SVM, newdata=testdata)
model_SVM <- svm(nextdayprice ~ . , data=traindata, probability = T)
clres_SVM <- predict(model_SVM, newdata=testdata, probability = T)
high_buying_props <- order(attributes(clres_SVM)$probabilities[,"higher"], decreasing = T)
attributes(clres_SVM)$probabilities[high_buying_props, ]
cm <- table(clres_RF, alldata[test_cases,"nextdayprice"])
cm <- table(clres_RF, dailystats_ETHEUR[test_cases,"nextdayprice"])
clres_DT
cm <- table(clres_DT, dailystats_ETHEUR[test_cases,"nextdayprice"])
(accuracy_DT <- (sum(diag(cm))/sum(as.vector(cm))))
cm <- table(clres_SVM, dailystats_ETHEUR[test_cases,"nextdayprice"])
(accuracy_SVM <- (sum(diag(cm))/sum(as.vector(cm))))
cm <- table(clres_KNN, dailystats_ETHEUR[test_cases,"nextdayprice"])
(accuracy_KNN <- (sum(diag(cm))/sum(as.vector(cm))))
model_RF <- randomForest(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ],
importance=T)
clres_RF <- predict(model_RF, newdata=alldata[test_cases,c("pNumResidents", features_selected)])
clres_RF <- predict(model_RF, newdata=dailystats_ETHEUR[test_cases,c("pNumResidents", features_selected)])
clres_RF <- predict(model_RF, newdata=dailystats_ETHEUR[test_cases,])
cm <- table(clres_RF, dailystats_ETHEUR[test_cases,"nextdayprice"])
(accuracy_RF <- (sum(diag(cm))/sum(as.vector(cm))))
used_packages <- c("lubridate",   # date/time conversions
"caret",       # cross-fold generation
"party",       # decision tree classifier
"class",       # kNN classifier
"e1071",       # SVM classifier
"randomForest" # random forest classifier
)
missing_packages <- setdiff(used_packages, installed.packages())
if(length(missing_packages)>0){install.packages(missing_packages)}
lapply(used_packages, require, character.only = TRUE)
rm(used_packages, missing_packages)
trades_ETHEUR <- read.csv("trades_ETHEUR.csv", encoding = "UTF-8")
trades_XBTEUR <- read.csv("trades_XBTEUR.csv", encoding = "UTF-8")
trades_ETHEUR$Time_Format <- as_datetime(trades_ETHEUR$Time)
trades_ETHEUR$BS <- as.factor(trades_ETHEUR$BS)
trades_ETHEUR$ML <- as.factor(trades_ETHEUR$ML)
summary(trades_ETHEUR$Time_Format)
trades_ETHEUR$day <- date(trades_ETHEUR$Time_Format)
dailystats_ETHEUR <- data.frame(
avg_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, mean), #TODO: is that correct?
min_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, min),
max_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, max),
volume = tapply(trades_ETHEUR$Volume, trades_ETHEUR$day, sum)
)
dailystats_ETHEUR$price_diff_1d <- 0
dailystats_ETHEUR$price_diff_2d <- 0
dailystats_ETHEUR$price_diff_3d <- 0
dailystats_ETHEUR$price_diff_4d <- 0
dailystats_ETHEUR$price_diff_5d <- 0
dailystats_ETHEUR$price_var_10d <- 0
for(i in 10:(nrow(dailystats_ETHEUR))){
dailystats_ETHEUR[i, c("price_diff_1d", "price_diff_2d", "price_diff_3d",
"price_diff_4d", "price_diff_5d")] <-
dailystats_ETHEUR$avg_price[i] - dailystats_ETHEUR$avg_price[i-c(1:5)]
dailystats_ETHEUR$price_var_10d[i] <- var(dailystats_ETHEUR$avg_price[i-c(0:9)])
}
plot(dailystats_ETHEUR$avg_price, type="l", ylim=c(0,400), main="Price per day ETHEUR",
ylab="ETHEUR", xlab="Day since 2015-08-07")
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]),
col = "lightblue", border = "lightblue")
lines(dailystats_ETHEUR$avg_price)
trades_ETHEUR$Time_Format <- as_datetime(trades_ETHEUR$Time)
trades_ETHEUR$BS <- as.factor(trades_ETHEUR$BS)
trades_ETHEUR$ML <- as.factor(trades_ETHEUR$ML)
summary(trades_ETHEUR$Time_Format)
#> calculate features per day ----
trades_ETHEUR$day <- date(trades_ETHEUR$Time_Format)
dailystats_ETHEUR <- data.frame(
avg_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, mean), #TODO: is that correct?
min_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, min),
max_price = tapply(trades_ETHEUR$Price, trades_ETHEUR$day, max),
volume = tapply(trades_ETHEUR$Volume, trades_ETHEUR$day, sum)
)
dailystats_ETHEUR$price_diff_1d <- 0
dailystats_ETHEUR$price_diff_2d <- 0
dailystats_ETHEUR$price_diff_3d <- 0
dailystats_ETHEUR$price_diff_4d <- 0
dailystats_ETHEUR$price_diff_5d <- 0
dailystats_ETHEUR$price_var_10d <- 0
for(i in 10:(nrow(dailystats_ETHEUR))){
dailystats_ETHEUR[i, c("price_diff_1d", "price_diff_2d", "price_diff_3d",
"price_diff_4d", "price_diff_5d")] <-
dailystats_ETHEUR$avg_price[i] - dailystats_ETHEUR$avg_price[i-c(1:5)]
dailystats_ETHEUR$price_var_10d[i] <- var(dailystats_ETHEUR$avg_price[i-c(0:9)])
}
#> plot the price ranges per day ----
plot(dailystats_ETHEUR$avg_price, type="l", ylim=c(0,400), main="Price per day ETHEUR",
ylab="ETHEUR", xlab="Day since 2015-08-07")
# lines(dailystats_ETHEUR$max_price, col=2)
# lines(dailystats_ETHEUR$min_price, col=2)
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]),
col = "lightblue", border = "lightblue")
lines(dailystats_ETHEUR$avg_price)
threshold <- 0.125 * sd(diff(dailystats_ETHEUR$avg_price))
dailystats_ETHEUR$nextdayprice <- ""
for(i in 1:(nrow(dailystats_ETHEUR)-1)){
diff_nextday <- dailystats_ETHEUR$avg_price[i+1] - dailystats_ETHEUR$avg_price[i]
if(diff_nextday > threshold){
dailystats_ETHEUR$nextdayprice[i] <- "higher"
} else if(diff_nextday < -threshold){
dailystats_ETHEUR$nextdayprice[i] <- "lower"
} else {
dailystats_ETHEUR$nextdayprice[i] <- "equal"
}
}
dailystats_ETHEUR$nextdayprice[dailystats_ETHEUR$nextdayprice==""] <- NA
dailystats_ETHEUR$nextdayprice <- ordered(dailystats_ETHEUR$nextdayprice,
levels=c("lower", "equal", "higher"))
summary(dailystats_ETHEUR$nextdayprice)
dailystats_ETHEUR <- dailystats_ETHEUR[!apply(dailystats_ETHEUR, 1, anyNA), ]
set.seed(1000)
xfolds <- createFolds(dailystats_ETHEUR$nextdayprice, k=10)
test_cases     <- 1:nrow(dailystats_ETHEUR) %in% xfolds$Fold01
training_cases <- !test_cases
model_DT <- ctree(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ])
clres_DT <- predict(model_DT, newdata=dailystats_ETHEUR[test_cases,])
plot(model_DT)
model_RF <- randomForest(nextdayprice ~ . ,
data=dailystats_ETHEUR[training_cases, ],
importance=T)
clres_RF <- predict(model_RF, newdata=dailystats_ETHEUR[test_cases,])
importance(model_RF)
features <- setdiff(colnames(dailystats_ETHEUR), "nextdayprice")
testdata  <- dailystats_ETHEUR[test_cases, ]
traindata <- dailystats_ETHEUR[training_cases, ]
clres_KNN <- knn(train = traindata[, features], test = testdata[, features],
cl = traindata$nextdayprice, k = 5)
testdata  <- dailystats_ETHEUR[test_cases, ]
traindata <- dailystats_ETHEUR[training_cases, ]
clres_KNN <- knn(train = traindata[, features], test = testdata[, features],
cl = traindata$nextdayprice, k = 5, prob = T)
prob <- attr(clres_KNN, "prob")
model_SVM <- svm(nextdayprice ~ . , data=traindata)
clres_SVM <- predict(model_SVM, newdata=testdata)
model_SVM <- svm(nextdayprice ~ . , data=traindata, probability = T)
clres_SVM <- predict(model_SVM, newdata=testdata, probability = T)
high_buying_props <- order(attributes(clres_SVM)$probabilities[,"higher"], decreasing = T)
attributes(clres_SVM)$probabilities[high_buying_props, ]
cm <- table(clres_RF, dailystats_ETHEUR[test_cases,"nextdayprice"])
(accuracy_RF <- (sum(diag(cm))/sum(as.vector(cm))))
cm <- table(clres_DT, dailystats_ETHEUR[test_cases,"nextdayprice"])
(accuracy_DT <- (sum(diag(cm))/sum(as.vector(cm))))
cm <- table(clres_SVM, dailystats_ETHEUR[test_cases,"nextdayprice"])
(accuracy_SVM <- (sum(diag(cm))/sum(as.vector(cm))))
cm <- table(clres_KNN, dailystats_ETHEUR[test_cases,"nextdayprice"])
(accuracy_KNN <- (sum(diag(cm))/sum(as.vector(cm))))
trades_XBTEUR$Time_Format <- as_datetime(trades_XBTEUR$Time)
trades_XBTEUR$BS <- as.factor(trades_XBTEUR$BS)
trades_XBTEUR$ML <- as.factor(trades_XBTEUR$ML)
plot(dailystats_ETHEUR$avg_price, type="l", ylim=c(0,400), main="Price per day ETHEUR",
ylab="ETHEUR", xlab="Day since 2015-08-07")
# lines(dailystats_ETHEUR$max_price, col=2)
# lines(dailystats_ETHEUR$min_price, col=2)
polygon(x=c(1:nrow(dailystats_ETHEUR), nrow(dailystats_ETHEUR):1),
y=c(dailystats_ETHEUR$max_price,
dailystats_ETHEUR$min_price[nrow(dailystats_ETHEUR):1]),
col = "lightblue", border = "lightblue")
lines(dailystats_ETHEUR$avg_price)
View(trades_ETHEUR)
?ctree
